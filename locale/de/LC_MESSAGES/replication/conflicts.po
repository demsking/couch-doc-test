# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#   http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-11-18 09:39+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.10.0\n"

# 3b657f8ee6c64675bccb3f92ea0c2cd4
#: ../../../src/replication/conflicts.rst:18
msgid "Replication and conflict model"
msgstr ""

# d184d4380ba94519975a0266b21b6001
#: ../../../src/replication/conflicts.rst:20
msgid "Let's take the following example to illustrate replication and conflict handling."
msgstr ""

# 6c69331e302d427fa39a2810636d534f
#: ../../../src/replication/conflicts.rst:22
msgid "Alice has a document containing Bob's business card;"
msgstr ""

# 283259d968264fe3be2a4c6b3488f04e
#: ../../../src/replication/conflicts.rst:23
msgid "She synchronizes it between her desktop PC and her laptop;"
msgstr ""

# 1e1350890c89427692fa35f44b4e23c3
#: ../../../src/replication/conflicts.rst:24
msgid "On the desktop PC, she updates Bob's E-mail address; Without syncing again, she updates Bob's mobile number on the laptop;"
msgstr ""

# a8f16d7a705148b79f74e3ee03a0608d
#: ../../../src/replication/conflicts.rst:26
msgid "Then she replicates the two to each other again."
msgstr ""

# ed17b78b787d4dbc809b831e2e7d2710
#: ../../../src/replication/conflicts.rst:28
msgid "So on the desktop the document has Bob's new E-mail address and his old mobile number, and on the laptop it has his old E-mail address and his new mobile number."
msgstr ""

# 4ba1d0f260ee405d99915a03368b1669
#: ../../../src/replication/conflicts.rst:32
msgid "The question is, what happens to these conflicting updated documents?"
msgstr ""

# 4b6824a51a9f4873b76e9b431901597c
#: ../../../src/replication/conflicts.rst:35
msgid "CouchDB replication"
msgstr ""

# ada0293959fa493498349ddc9d951036
#: ../../../src/replication/conflicts.rst:37
msgid "CouchDB works with JSON documents inside databases. Replication of databases takes place over HTTP, and can be either a \"pull\" or a \"push\", but is unidirectional. So the easiest way to perform a full sync is to do a \"push\" followed by a \"pull\" (or vice versa)."
msgstr ""

# 5831fc49693540f8b20b52d8f943f1d7
#: ../../../src/replication/conflicts.rst:42
msgid "So, Alice creates v1 and sync it. She updates to v2a on one side and v2b on the other, and then replicates. What happens?"
msgstr ""

# 83fcf678627b4b729f99ba3ed808c002
#: ../../../src/replication/conflicts.rst:45
msgid "The answer is simple: both versions exist on both sides!"
msgstr ""

# a388774f27874fc7a82f0cafe8e73beb
#: ../../../src/replication/conflicts.rst:77
msgid "After all, this is not a filesystem, so there's no restriction that only one document can exist with the name /db/bob. These are just \"conflicting\" revisions under the same name."
msgstr ""

# e311e56dc8744964877418f55beeeaf5
#: ../../../src/replication/conflicts.rst:81
msgid "Because the changes are always replicated, the data is safe. Both machines have identical copies of both documents, so failure of a hard drive on either side won't lose any of the changes."
msgstr ""

# ccd7cfe98e58425eb1ebbddd86b8b955
#: ../../../src/replication/conflicts.rst:85
msgid "Another thing to notice is that peers do not have to be configured or tracked. You can do regular replications to peers, or you can do one-off, ad-hoc pushes or pulls. After the replication has taken place, there is no record kept of which peer any particular document or revision came from."
msgstr ""

# 8ac066e3df334e989a2a96b401b6f704
#: ../../../src/replication/conflicts.rst:90
msgid "So the question now is: what happens when you try to read /db/bob? By default, CouchDB picks one arbitrary revision as the \"winner\", using a deterministic algorithm so that the same choice will be made on all peers. The same happens with views: the deterministically-chosen winner is the only revision fed into your map function."
msgstr ""

# a9cd0d778c244bbc8213a5f75f07fe20
#: ../../../src/replication/conflicts.rst:96
msgid "Let's say that the winner is v2a. On the desktop, if Alice reads the document she'll see v2a, which is what she saved there. But on the laptop, after replication, she'll also see only v2a. It could look as if the changes she made there have been lost - but of course they have not, they have just been hidden away as a conflicting revision. But eventually she'll need these changes merged into Bob's business card, otherwise they will effectively have been lost."
msgstr ""

# e8445d3c8e934fa382cfc02ed22106f2
#: ../../../src/replication/conflicts.rst:103
msgid "Any sensible business-card application will, at minimum, have to present the conflicting versions to Alice and allow her to create a new version incorporating information from them all. Ideally it would merge the updates itself."
msgstr ""

# 80e51ddf5ab643dab462ada71dd8bccb
#: ../../../src/replication/conflicts.rst:109
msgid "Conflict avoidance"
msgstr ""

# c45f07aaaf0b48b3be81be305e1931a6
#: ../../../src/replication/conflicts.rst:111
msgid "When working on a single node, CouchDB will avoid creating conflicting revisions by returning a :statuscode:`409` error. This is because, when you PUT a new version of a document, you must give the ``_rev`` of the previous version. If that ``_rev`` has already been superseded, the update is rejected with a  :statuscode:`409` response."
msgstr ""

# 2cf81c348ef94fa1af2da43581358f0f
#: ../../../src/replication/conflicts.rst:117
msgid "So imagine two users on the same node are fetching Bob's business card, updating it concurrently, and writing it back:"
msgstr ""

# 7390ff78b6144d638ebeb3874b0d4462
#: ../../../src/replication/conflicts.rst:134
msgid "User2's changes are rejected, so it's up to the app to fetch /db/bob again, and either:"
msgstr ""

# 56c4993b8ed44cb9b68a5887bbd15b00
#: ../../../src/replication/conflicts.rst:137
msgid "apply the same changes as were applied to the earlier revision, and submit a new PUT"
msgstr ""

# a17d79c3a0de4284aaa0be75f00b26fd
#: ../../../src/replication/conflicts.rst:139
msgid "redisplay the document so the user has to edit it again"
msgstr ""

# c8843544d3a04e58946c5f63876fcca2
#: ../../../src/replication/conflicts.rst:140
msgid "just overwrite it with the document being saved before (which is not advisable, as user1's changes will be silently lost)"
msgstr ""

# b6217cb8e63a4b398d4d540e37eda004
#: ../../../src/replication/conflicts.rst:143
msgid "So when working in this mode, your application still has to be able to handle these conflicts and have a suitable retry strategy, but these conflicts never end up inside the database itself."
msgstr ""

# e623d27607af449d8a32c3cdb45f2536
#: ../../../src/replication/conflicts.rst:148
msgid "Conflicts in batches"
msgstr ""

# ba46c9c68b7c49de90cfc3d39a29fd0c
#: ../../../src/replication/conflicts.rst:150
msgid "There are two different ways that conflicts can end up in the database:"
msgstr ""

# b001b689df4e4fd49ec7ed14aa8d1ad2
#: ../../../src/replication/conflicts.rst:152
msgid "Conflicting changes made on different databases, which are replicated to each other, as shown earlier."
msgstr ""

# 43aaf136739149cb85e1e821d4c3466f
#: ../../../src/replication/conflicts.rst:154
msgid "Changes are written to the database using ``_bulk_docs`` and all_or_nothing, which bypasses the 409 mechanism."
msgstr ""

# 575ac80202224bd5baa60287f2628d99
#: ../../../src/replication/conflicts.rst:157
msgid "The :ref:`_bulk_docs API <api/db/bulk_docs>` lets you submit multiple updates (and/or deletes) in a single HTTP POST. Normally, these are treated as independent updates; some in the batch may fail because the `_rev` is stale (just like a 409 from a PUT) whilst others are written successfully. The response from ``_bulk_docs`` lists the success/fail separately for each document in the batch."
msgstr ""

# 13976a12f35b48269a1eee6766db55a9
#: ../../../src/replication/conflicts.rst:164
msgid "However there is another mode of working, whereby you specify ``{\"all_or_nothing\":true}`` as part of the request. This is CouchDB's nearest equivalent of a \"transaction\", but it's not the same as a database transaction which can fail and roll back. Rather, it means that all of the changes in the request will be forcibly applied to the database, even if that introduces conflicts. The only guarantee you are given is that they will either all be applied to the database, or none of them (e.g. if the power is pulled out before the update is finished writing to disk)."
msgstr ""

# 2f4719e4b9784f1cb890b03c0b42fd6c
#: ../../../src/replication/conflicts.rst:173
msgid "So this gives you a way to introduce conflicts within a single database instance. If you choose to do this instead of PUT, it means you don't have to write any code for the possibility of getting a 409 response, because you will never get one. Rather, you have to deal with conflicts appearing later in the database, which is what you'd have to do in a multi-master application anyway."
msgstr ""

# 286b9921348748778b45acd2b94ab496
#: ../../../src/replication/conflicts.rst:195
msgid "Revision tree"
msgstr ""

# 65d893ea073240169181c109b77d5a53
#: ../../../src/replication/conflicts.rst:197
msgid "When you update a document in CouchDB, it keeps a list of the previous revisions. In the case where conflicting updates are introduced, this history branches into a tree, where the current conflicting revisions for this document form the tips (leaf nodes) of this tree:"
msgstr ""

# f703a3ec32454517bf6b5cbf5543284f
#: ../../../src/replication/conflicts.rst:208
msgid "Each branch can then extend its history - for example if you read revision r2b and then PUT with ?rev=r2b then you will make a new revision along that particular branch."
msgstr ""

# 7baacf4da304432c9983504a2a581f3e
#: ../../../src/replication/conflicts.rst:218
msgid "Here, (r4a, r3b, r3c) are the set of conflicting revisions. The way you resolve a conflict is to delete the leaf nodes along the other branches. So when you combine (r4a+r3b+r3c) into a single merged document, you would replace r4a and delete r3b and r3c."
msgstr ""

# b8ebb21578e34250a5c15d978bbced15
#: ../../../src/replication/conflicts.rst:229
msgid "Note that r4b and r4c still exist as leaf nodes in the history tree, but as deleted docs. You can retrieve them but they will be marked ``\"_deleted\":true``."
msgstr ""

# 5132e473fb0648098cc64e9659c3622b
#: ../../../src/replication/conflicts.rst:232
msgid "When you compact a database, the bodies of all the non-leaf documents are discarded. However, the list of historical _revs is retained, for the benefit of later conflict resolution in case you meet any old replicas of the database at some time in future. There is \"revision pruning\" to stop this getting arbitrarily large."
msgstr ""

# 0722c800360f4b06b28954d8694e0a8f
#: ../../../src/replication/conflicts.rst:239
msgid "Working with conflicting documents"
msgstr ""

# da1bde9e8a334f3886f21548a6927fc4
#: ../../../src/replication/conflicts.rst:241
msgid "The basic :get:`/{doc}/{docid}` operation will not show you any information about conflicts. You see only the deterministically-chosen winner, and get no indication as to whether other conflicting revisions exist or not:"
msgstr ""

# 2c88d456c5f44be98af72e3fd7357303
#: ../../../src/replication/conflicts.rst:253
msgid "If you do ``GET /db/bob?conflicts=true``, and the document is in a conflict state, then you will get the winner plus a _conflicts member containing an array of the revs of the other, conflicting revision(s). You can then fetch them individually using subsequent ``GET /db/bob?rev=xxxx`` operations:"
msgstr ""

# f8b323a9f6ef43c8ac5bce06f8867db3
#: ../../../src/replication/conflicts.rst:270
msgid "If you do ``GET /db/bob?open_revs=all`` then you will get all the leaf nodes of the revision tree. This will give you all the current conflicts, but will also give you leaf nodes which have been deleted (i.e. parts of the conflict history which have since been resolved). You can remove these by filtering out documents with ``\"_deleted\":true``:"
msgstr ""

# cd1e0c3203cb4bdfae807c52022548f6
#: ../../../src/replication/conflicts.rst:284
msgid "The ``\"ok\"`` tag is an artifact of ``open_revs``, which also lets you list explicit revisions as a JSON array, e.g. ``open_revs=[rev1,rev2,rev3]``. In this form, it would be possible to request a revision which is now missing, because the database has been compacted."
msgstr ""

# 07d103f6faaf4b04b4f547fabfd0d280
#: ../../../src/replication/conflicts.rst:290
msgid "The order of revisions returned by ``open_revs=all`` is **NOT** related to the deterministic \"winning\" algorithm. In the above example, the winning revision is 2-b91b... and happens to be returned last, but in other cases it can be returned in a different position."
msgstr ""

# 1eb7b1b3a1304bc1aa2150b544a38cff
#: ../../../src/replication/conflicts.rst:295
msgid "Once you have retrieved all the conflicting revisions, your application can then choose to display them all to the user. Or it could attempt to merge them, write back the merged version, and delete the conflicting versions - that is, to resolve the conflict permanently."
msgstr ""

# 428f65638e604fce82025c72cca12bfa
#: ../../../src/replication/conflicts.rst:300
msgid "As described above, you need to update one revision and delete all the conflicting revisions explicitly. This can be done using a single `POST` to ``_bulk_docs``, setting ``\"_deleted\":true`` on those revisions you wish to delete."
msgstr ""

# 17216c295a7b4bbbb511a56731104382
#: ../../../src/replication/conflicts.rst:306
msgid "Multiple document API"
msgstr ""

# fc543baaa54a4159abe7f2f39c663e4f
#: ../../../src/replication/conflicts.rst:308
msgid "You can fetch multiple documents at once using ``include_docs=true`` on a view. However, a ``conflicts=true`` request is ignored; the \"doc\" part of the value never includes a ``_conflicts`` member. Hence you would need to do another query to determine for each document whether it is in a conflicting state:"
msgstr ""

# 03f77d9227a544e39b3cf8af6e63b4fe
#: ../../../src/replication/conflicts.rst:353
msgid "View map functions"
msgstr ""

# 2b3c9c17ca134a399e600fb8032f2993
#: ../../../src/replication/conflicts.rst:355
msgid "Views only get the winning revision of a document. However they do also get a ``_conflicts`` member if there are any conflicting revisions. This means you can write a view whose job is specifically to locate documents with conflicts. Here is a simple map function which achieves this:"
msgstr ""

# cd216a11523e4beaabc8ed959f6ce036
#: ../../../src/replication/conflicts.rst:368
msgid "which gives the following output:"
msgstr ""

# e7540781e2eb4ec39d0f5cdde5323834
#: ../../../src/replication/conflicts.rst:388
msgid "If you do this, you can have a separate \"sweep\" process which periodically scans your database, looks for documents which have conflicts, fetches the conflicting revisions, and resolves them."
msgstr ""

# f512ab08c2464f7b98493619c2b18220
#: ../../../src/replication/conflicts.rst:392
msgid "Whilst this keeps the main application simple, the problem with this approach is that there will be a window between a conflict being introduced and it being resolved. From a user's viewpoint, this may appear that the document they just saved successfully may suddenly lose their changes, only to be resurrected some time later. This may or may not be acceptable."
msgstr ""

# bd3acc6a25914196b18b064e0201b861
#: ../../../src/replication/conflicts.rst:398
msgid "Also, it's easy to forget to start the sweeper, or not to implement it properly, and this will introduce odd behaviour which will be hard to track down."
msgstr ""

# 9d30addca3f34391a346424559b7bf03
#: ../../../src/replication/conflicts.rst:401
msgid "CouchDB's \"winning\" revision algorithm may mean that information drops out of a view until a conflict has been resolved. Consider Bob's business card again; suppose Alice has a view which emits mobile numbers, so that her telephony application can display the caller's name based on caller ID. If there are conflicting documents with Bob's old and new mobile numbers, and they happen to be resolved in favour of Bob's old number, then the view won't be able to recognise his new one. In this particular case, the application might have preferred to put information from both the conflicting documents into the view, but this currently isn't possible."
msgstr ""

# b5f8122ef965482e900a1992278ff0df
#: ../../../src/replication/conflicts.rst:411
msgid "Suggested algorithm to fetch a document with conflict resolution:"
msgstr ""

# 2f58e049523b4bc0980fdd829882b8c8
#: ../../../src/replication/conflicts.rst:413
msgid "Get document via ``GET docid?conflicts=true`` request;"
msgstr ""

# 1ffba9b341b54760bbc1786b26aaf99a
#: ../../../src/replication/conflicts.rst:414
msgid "For each member in the ``_conflicts`` array call ``GET docid?rev=xxx``. If any errors occur at this stage, restart from step 1. (There could be a race where someone else has already resolved this conflict and deleted that rev)"
msgstr ""

# 13af4cb8ac5f4bd18bb87e9f2b2cd114
#: ../../../src/replication/conflicts.rst:418
msgid "Perform application-specific merging"
msgstr ""

# 71b37baeb2694884a4778b07d48462ad
#: ../../../src/replication/conflicts.rst:419
msgid "Write ``_bulk_docs`` with an update to the first rev and deletes of the other revs."
msgstr ""

# 5c1d821f3c9249b2a7a4ad5805fb8c91
#: ../../../src/replication/conflicts.rst:422
msgid "This could either be done on every read (in which case you could replace all calls to GET in your application with calls to a library which does the above), or as part of your sweeper code."
msgstr ""

# c50818eda10649a590a226528b222cf6
#: ../../../src/replication/conflicts.rst:426
msgid "And here is an example of this in Ruby using the low-level `RestClient`_:"
msgstr ""

# e04be7bd8d554e6384c83f4f28fc9504
#: ../../../src/replication/conflicts.rst:500
msgid "An application written this way never has to deal with a ``PUT 409``, and is automatically multi-master capable."
msgstr ""

# caeb6274a137402abd80eb398f33822a
#: ../../../src/replication/conflicts.rst:503
msgid "You can see that it's straightforward enough when you know what you're doing. It's just that CouchDB doesn't currently provide a convenient HTTP API for \"fetch all conflicting revisions\", nor \"PUT to supersede these N revisions\", so you need to wrap these yourself. I also don't know of any client-side libraries which provide support for this."
msgstr ""

# 317e675d5c0d4d429db74b1f3e1d1790
#: ../../../src/replication/conflicts.rst:510
msgid "Merging and revision history"
msgstr ""

# c723c037db844b948d35e599ed46c885
#: ../../../src/replication/conflicts.rst:512
msgid "Actually performing the merge is an application-specific function. It depends on the structure of your data. Sometimes it will be easy: e.g. if a document contains a list which is only ever appended to, then you can perform a union of the two list versions."
msgstr ""

# 4dd2733fa57d438499b8e814bf609aee
#: ../../../src/replication/conflicts.rst:517
msgid "Some merge strategies look at the changes made to an object, compared to its previous version. This is how git's merge function works."
msgstr ""

# c8e12e66cea64dffa28071dc13fc7428
#: ../../../src/replication/conflicts.rst:520
msgid "For example, to merge Bob's business card versions v2a and v2b, you could look at the differences between v1 and v2b, and then apply these changes to v2a as well."
msgstr ""

# 602ca9be886b49c9b7a842c0e84a050c
#: ../../../src/replication/conflicts.rst:524
msgid "With CouchDB, you can sometimes get hold of old revisions of a document. For example, if you fetch ``/db/bob?rev=v2b&revs_info=true`` you'll get a list of the previous revision ids which ended up with revision v2b. Doing the same for v2a you can find their common ancestor revision. However if the database has been compacted, the content of that document revision will have been lost. ``revs_info`` will still show that v1 was an ancestor, but report it as \"missing\"::"
msgstr ""

# d2361eed9cde459982110e236f9187f2
#: ../../../src/replication/conflicts.rst:538
msgid "So if you want to work with diffs, the recommended way is to store those diffs within the new revision itself. That is: when you replace v1 with v2a, include an extra field or attachment in v2a which says which fields were changed from v1 to v2a. This unfortunately does mean additional book-keeping for your application."
msgstr ""

# 8f86d6f021b345aca11216140a2ac038
#: ../../../src/replication/conflicts.rst:545
msgid "Comparison with other replicating data stores"
msgstr ""

# 0380679832fa463485436577f396f761
#: ../../../src/replication/conflicts.rst:547
msgid "The same issues arise with other replicating systems, so it can be instructive to look at these and see how they compare with CouchDB. Please feel free to add other examples."
msgstr ""

# 6b4beab9bfbe42218b9625a830b78f32
#: ../../../src/replication/conflicts.rst:552
msgid "Unison"
msgstr ""

# 21bc6773c6b14fc78fa2b9b3b95f1f9d
#: ../../../src/replication/conflicts.rst:554
msgid "`Unison`_ is a bi-directional file synchronisation tool. In this case, the business card would be a file, say `bob.vcf`."
msgstr ""

# 05597bb6e37d4b10b03310fdc4ccb8e6
#: ../../../src/replication/conflicts.rst:559
msgid "When you run unison, changes propagate both ways. If a file has changed on one side but not the other, the new replaces the old. Unison maintains a local state file so that it knows whether a file has changed since the last successful replication."
msgstr ""

# 48f3db76db7143a1b3e9b7fdb892d735
#: ../../../src/replication/conflicts.rst:564
msgid "In our example it has changed on both sides. Only one file called `bob.vcf` can exist within the filesystem. Unison solves the problem by simply ducking out: the user can choose to replace the remote version with the local version, or vice versa (both of which would lose data), but the default action is to leave both sides unchanged."
msgstr ""

# d8633b710a8a4b04b115581c4f51f164
#: ../../../src/replication/conflicts.rst:570
msgid "From Alice's point of view, at least this is a simple solution. Whenever she's on the desktop she'll see the version she last edited on the desktop, and whenever she's on the laptop she'll see the version she last edited there."
msgstr ""

# 43eb736b6370461d9660a12aaf974fee
#: ../../../src/replication/conflicts.rst:574
msgid "But because no replication has actually taken place, the data is not protected. If her laptop hard drive dies, she'll lose all her changes made on the laptop; ditto if her desktop hard drive dies."
msgstr ""

# 5aeb04619c6548e0b97d8b62f66c88c4
#: ../../../src/replication/conflicts.rst:578
msgid "It's up to her to copy across one of the versions manually (under a different filename), merge the two, and then finally push the merged version to the other side."
msgstr ""

# 1f878569f21b494eb972b3c4fb450c3c
#: ../../../src/replication/conflicts.rst:582
msgid "Note also that the original file (version v1) has been lost by this point. So it's not going to be known from inspection alone which of v2a and v2b has the most up-to-date E-mail address for Bob, and which has the most up-to-date mobile number. Alice has to remember which she entered last."
msgstr ""

# cfd2be48e0e841ab94d368ddca56c30c
#: ../../../src/replication/conflicts.rst:589
msgid "Git"
msgstr ""

# 64ac7d3c3ef146489a1113d6871823a8
#: ../../../src/replication/conflicts.rst:591
msgid "`Git`_ is a well-known distributed source control system. Like Unison, git deals with files. However, git considers the state of a whole set of files as a single object, the \"tree\". Whenever you save an update, you create a \"commit\" which points to both the updated tree and the previous commit(s), which in turn point to the previous tree(s). You therefore have a full history of all the states of the files. This forms a branch, and a pointer is kept to the tip of the branch, from which you can work backwards to any previous state. The \"pointer\" is actually an SHA1 hash of the tip commit."
msgstr ""

# b927f0202ec949709294788a6f028b02
#: ../../../src/replication/conflicts.rst:602
msgid "If you are replicating with one or more peers, a separate branch is made for each of the peers. For example, you might have::"
msgstr ""

# 458cd83261f245dba23e128212162350
#: ../../../src/replication/conflicts.rst:609
msgid "In the normal way of working, replication is a \"pull\", importing changes from a remote peer into the local repository. A \"pull\" does two things: first \"fetch\" the state of the peer into the remote tracking branch for that peer; and then attempt to \"merge\" those changes into the local branch."
msgstr ""

# 34c33a8fde9c434898439de291a798ba
#: ../../../src/replication/conflicts.rst:614
msgid "Now let's consider the business card. Alice has created a git repo containing ``bob.vcf``, and cloned it across to the other machine. The branches look like this, where ``AAAAAAAA`` is the SHA1 of the commit::"
msgstr ""

# 72a0d155cde04aa1a14908935a51d694
#: ../../../src/replication/conflicts.rst:622
msgid "Now she makes a change on the desktop, and commits it into the desktop repo; then she makes a different change on the laptop, and commits it into the laptop repo::"
msgstr ""

# 2445597db7d5421cb689ecd6f1df8f3a
#: ../../../src/replication/conflicts.rst:630
msgid "Now on the desktop she does ``git pull laptop``. Firstly, the remote objects are copied across into the local repo and the remote tracking branch is updated::"
msgstr ""

# 8d1b82e18661484c8984a0661bd82002
#: ../../../src/replication/conflicts.rst:639
msgid "repo still contains AAAAAAAA because commits BBBBBBBB and CCCCCCCC point to it"
msgstr ""

# 1e53015625f94fc9b0f3610f639452f1
#: ../../../src/replication/conflicts.rst:641
msgid "Then git will attempt to merge the changes in. It can do this because it knows the parent commit to ``CCCCCCCC`` is ``AAAAAAAA``, so it takes a diff between ``AAAAAAAA`` and ``CCCCCCCC`` and tries to apply it to ``BBBBBBBB``."
msgstr ""

# e369602a477b4b7eabad91c48e408fc8
#: ../../../src/replication/conflicts.rst:645
msgid "If this is successful, then you'll get a new version with a merge commit::"
msgstr ""

# 0fd5decf5dc34e3c96c6b1cc8f23b3aa
#: ../../../src/replication/conflicts.rst:651
msgid "Then Alice has to logon to the laptop and run ``git pull desktop``. A similar process occurs. The remote tracking branch is updated::"
msgstr ""

# 2d3959ae66d74097a57a4ecbd20eeef6
#: ../../../src/replication/conflicts.rst:658
msgid "Then a merge takes place. This is a special-case: ``CCCCCCCC`` one of the parent commits of ``DDDDDDDD``, so the laptop can `fast forward` update from ``CCCCCCCC`` to ``DDDDDDDD`` directly without having to do any complex merging. This leaves the final state as::"
msgstr ""

# a33fde399b1641929dceb91910015bee
#: ../../../src/replication/conflicts.rst:667
msgid "Now this is all and good, but you may wonder how this is relevant when thinking about CouchDB."
msgstr ""

# 49b9f399b63c4149a06d09522f5a95e9
#: ../../../src/replication/conflicts.rst:670
msgid "Firstly, note what happens in the case when the merge algorithm fails. The changes are still propagated from the remote repo into the local one, and are available in the remote tracking branch; so unlike Unison, you know the data is protected. It's just that the local working copy may fail to update, or may diverge from the remote version. It's up to you to create and commit the combined version yourself, but you are guaranteed to have all the history you might need to do this."
msgstr ""

# 91de82e7ac054382a331cd8e51871190
#: ../../../src/replication/conflicts.rst:678
msgid "Note that whilst it's possible to build new merge algorithms into Git, the standard ones are focused on line-based changes to source code. They don't work well for XML or JSON if it's presented without any line breaks."
msgstr ""

# 2c4dcfaaa15c4adf86e45ae8e1e114d0
#: ../../../src/replication/conflicts.rst:682
msgid "The other interesting consideration is multiple peers. In this case you have multiple remote tracking branches, some of which may match your local branch, some of which may be behind you, and some of which may be ahead of you (i.e. contain changes that you haven't yet merged)::"
msgstr ""

# dae22c91eba04a778af58ca9704db796
#: ../../../src/replication/conflicts.rst:692
msgid "Note that each peer is explicitly tracked, and therefore has to be explicitly created. If a peer becomes stale or is no longer needed, it's up to you to remove it from your configuration and delete the remote tracking branch. This is different to CouchDB, which doesn't keep any peer state in the database."
msgstr ""

# bd6494d7f952456b8496a5e65c5d8186
#: ../../../src/replication/conflicts.rst:697
msgid "Another difference with git is that it maintains all history back to time zero - git compaction keeps diffs between all those versions in order to reduce size, but CouchDB discards them. If you are constantly updating a document, the size of a git repo would grow forever. It is possible (with some effort) to use \"history rewriting\" to make git forget commits earlier than a particular one."
msgstr ""

# 5243e6b9c5444771855aedd3b62b310b
#: ../../../src/replication/conflicts.rst:708
msgid "What is the CouchDB replication protocol? Is it like Git?"
msgstr ""

# 0a0fca93e7174992be3b85f2770fe4e4
#: ../../../src/replication/conflicts.rst:710
msgid "Jason Smith"
msgstr ""

# 04d6c578c0cc4b94b146c509fc84a889
#: ../../../src/replication/conflicts.rst:711
msgid "2011-01-29"
msgstr ""

# f662d52a9cfb42ab94819b6a1d28f8d6
#: ../../../src/replication/conflicts.rst:712
msgid "http://stackoverflow.com/questions/4766391/what-is-the-couchdb-replication-protocol-is-it-like-git"
msgstr ""

# 8bca9fc00ecf4b3392b3e5fd9ac7814e
#: ../../../src/replication/conflicts.rst:714
msgid "**Key points**"
msgstr ""

# 1901f8cb3acf408f98f678c4ad426b30
#: ../../../src/replication/conflicts.rst:716
msgid "**If you know Git, then you know how Couch replication works.** Replicating is *very* similar to pushing or pulling with distributed source managers like Git."
msgstr ""

# afbd9e4287774cedb5d91d6022cd48ce
#: ../../../src/replication/conflicts.rst:719
msgid "**CouchDB replication does not have its own protocol.** A replicator simply connects to two DBs as a client, then reads from one and writes to the other. Push replication is reading the local data and updating the remote DB; pull replication is vice versa."
msgstr ""

# 7bb9886da4a947339f7d46049710a436
#: ../../../src/replication/conflicts.rst:724
msgid "**Fun fact 1**: The replicator is actually an independent Erlang application, in its own process. It connects to both couches, then reads records from one and writes them to the other."
msgstr ""

# 9c180edb19e6491f8eff5e0f49292178
#: ../../../src/replication/conflicts.rst:727
msgid "**Fun fact 2**: CouchDB has no way of knowing who is a normal client and who is a replicator (let alone whether the replication is push or pull). It all looks like client connections. Some of them read records. Some of them write records."
msgstr ""

# 19fe7e5048af4757a557e1976e5df4e0
#: ../../../src/replication/conflicts.rst:732
msgid "**Everything flows from the data model**"
msgstr ""

# ac89e97fc8054c189e594186c12d6474
#: ../../../src/replication/conflicts.rst:734
msgid "The replication algorithm is trivial, uninteresting. A trained monkey could design it. It's simple because the cleverness is the data model, which has these useful characteristics:"
msgstr ""

# 065295cde98f4c04a43f59c4c835ea95
#: ../../../src/replication/conflicts.rst:738
msgid "Every record in CouchDB is completely independent of all others. That sucks if you want to do a JOIN or a transaction, but it's awesome if you want to write a replicator. Just figure out how to replicate one record, and then repeat that for each record."
msgstr ""

# 121ea7974e4a4b859e0c6903330f3656
#: ../../../src/replication/conflicts.rst:742
msgid "Like Git, records have a linked-list revision history. A record's revision ID is the checksum of its own data. Subsequent revision IDs are checksums of: the new data, plus the revision ID of the previous."
msgstr ""

# 56005edeae0c4fd981c8f5943711ae5b
#: ../../../src/replication/conflicts.rst:746
msgid "In addition to application data (``{\"name\": \"Jason\", \"awesome\": true}``), every record stores the evolutionary timeline of all previous revision IDs leading up to itself."
msgstr ""

# 49abd579615e4a91ace2549f4671d869
#: ../../../src/replication/conflicts.rst:750
msgid "Exercise: Take a moment of quiet reflection. Consider any two different records, A and B. If A's revision ID appears in B's timeline, then B definitely evolved from A. Now consider Git's fast-forward merges. Do you hear that? That is the sound of your mind being blown."
msgstr ""

# f9463f88556f4a96aba21eb90b9cf625
#: ../../../src/replication/conflicts.rst:755
msgid "Git isn't really a linear list. It has forks, when one parent has multiple children. CouchDB has that too."
msgstr ""

# 14ecfcd6f705402881b24b3cfe6506eb
#: ../../../src/replication/conflicts.rst:758
msgid "Exercise: Compare two different records, A and B. A's revision ID does not appear in B's timeline; however, one revision ID, C, is in both A's and B's timeline. Thus A didn't evolve from B. B didn't evolve from A. But rather, A and B have a common ancestor C. In Git, that is a \"fork.\" In CouchDB, it's a \"conflict.\""
msgstr ""

# a7df46b4e58e4481bced45ff24562a40
#: ../../../src/replication/conflicts.rst:764
msgid "In Git, if both children go on to develop their timelines independently, that's cool. Forks totally support that."
msgstr ""

# 862f83ad1441479ead7142172e5a5fd3
#: ../../../src/replication/conflicts.rst:766
msgid "In CouchDB, if both children go on to develop their timelines independently, that cool too. Conflicts totally support that."
msgstr ""

# cbc3f03cc8da428c85e0345d044f5f6f
#: ../../../src/replication/conflicts.rst:768
msgid "**Fun fact 3**: CouchDB \"conflicts\" do not correspond to Git \"conflicts.\" A Couch conflict is a divergent revision history, what Git calls a \"fork.\" For this reason the CouchDB community pronounces \"conflict\" with a silent `n`: \"co-flicked.\""
msgstr ""

# be053a2769624d528e4fb26a6f3a489b
#: ../../../src/replication/conflicts.rst:773
msgid "Git also has merges, when one child has multiple parents. CouchDB *sort* of has that too."
msgstr ""

# 017b81ec4aab425792ad41c5d50db97b
#: ../../../src/replication/conflicts.rst:776
msgid "**In the data model, there is no merge.** The client simply marks one timeline as deleted and continues to work with the only extant timeline."
msgstr ""

# fd4799e53f014e049b107085bd6b3d9f
#: ../../../src/replication/conflicts.rst:778
msgid "**In the application, it feels like a merge.** Typically, the client merges the *data* from each timeline in an application-specific way. Then it writes the new data to the timeline. In Git, this is like copying and pasting the changes from branch A into branch B, then commiting to branch B and deleting branch A. The data was merged, but there was no `git merge`."
msgstr ""

# 9147019c65da4c448cca52cf050d6dec
#: ../../../src/replication/conflicts.rst:784
msgid "These behaviors are different because, in Git, the timeline itself is important; but in CouchDB, the data is important and the timeline is incidental—it's just there to support replication. That is one reason why CouchDB's built-in revisioning is inappropriate for storing revision data like a wiki page."
msgstr ""

# c9c208841f924bea81b1c664f2b7b116
#: ../../../src/replication/conflicts.rst:790
msgid "**Final notes**"
msgstr ""

# 88147dd5293740279b43432bf62f40f4
#: ../../../src/replication/conflicts.rst:792
msgid "At least one sentence in this writeup (possibly this one) is complete BS."
msgstr ""
